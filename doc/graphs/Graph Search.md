# Обхід графу
У комп'ютерних науках, пошук по графу (або обхід графа) це процес проходження (перевірки або оновлення) кожної вершини графу. Такі алгоритми пошуку класифікують відповідно до порядку проходження вершин. _Пошук по дереву_ є особливим випадком пошуку по графу.

![](https://upload.wikimedia.org/wikipedia/commons/c/c7/Graph-scan.png)
## Пошук у глибину
Пошук у глибину по графу, це алгоритм проходження скінченного графу. Алгоритм проходить наступні дочірні вершини, перш ніж буде проходити вершини того ж рівня; таким чином, він проходить граф у глибину спершу ніж буде проходити вершини в ширину. Стек (зазвичай це програмний стек виклику при роботі з рекурсією) є основним вузьким місцем при використанні цього алгоритму.

Алгоритм починає пошук із вибраної вершини «кореня»; і потім в ітеративному порядку проходить від поточної вершини до наступної невідвіданої вершини, до тих пір доки він не може більше знайти не дослідженої вершини для переходу кудись. Алгоритм потім здійснює рух назад по вже пройденим вершинам, доки не знайде наступну вершину, що ще не була пройдена. Тоді він пройде новий маршрут пошуку як у попередньому кроці, рухаючись назад кожного разу доки не зустріне кінець, і закінчить пошук лише коли рух назад призвів знов до вершини «кореня», що була на самому початку.
## Пошук у ширину
Пошук у ширину це інша техніка пошуку по скінченному графу. Цей алгоритм проходить суміжні вершини перш ніж переходити до дочірніх вершин, і як процес пошуку використовується черга. Цей алгоритм часто використовується для пошуку найкоротшого шляху від одної вершини до іншої.
## Алгоритм Дейкстри
### Загальна інформація
Алгоритм Дейкстри — алгоритм на графах, відкритий Дейкстрою. Знаходить найкоротший шлях від однієї вершини графа до всіх інших вершин. Класичний алгоритм Дейкстри працює тільки для графів без циклів від'ємної довжини.

Найпростіша реалізація алгоритму Дейкстри потребує `O(n^2)` дій. У ній використовується масив відстаней та масив позначок. На початку алгоритму відстані заповнюються великим позитивним числом (більшим максимального можливого шляху в графі), а масив позначок заповнюється нулями. Потім відстань для початкової вершини вважається рівною нулю і запускається основний цикл.

На кожному кроці циклу ми шукаємо вершину з мінімальною відстанню і прапором рівним нулю. Потім ми встановлюємо в ній позначку 1 і перевіряємо всі сусідні з нею вершини. Якщо в ній відстань більша, ніж сума відстані до поточної вершини і довжини ребра, то зменшуємо її. Цикл завершується коли позначки всіх вершин стають рівними 1.
### Приклад алгоритму
Зберігатимемо поточну мінімальну відстань до всіх вершин __V__ (від даної вершини __a__) і на кожному кроці алгоритму намагатимемося зменшити цю відстань. Спочатку встановимо відстані до всіх вершин рівними нескінченості, а до вершини __а__ — нулю.

![](https://upload.wikimedia.org/wikipedia/commons/d/de/Dijkstra_graph0.PNG)

Хай потрібно знайти відстані від 1-ї вершини до всіх інших. Кружечками позначені вершини, лініями — шляхи між ними («дуги»). Над дугами позначена їх «ціна» — довжина шляху. Надписом над кружечком позначена поточна найкоротша відстань до вершини.

![](https://upload.wikimedia.org/wikipedia/commons/a/aa/Dijkstra_graph1.PNG)

Ініціалізація. Відстань до всіх вершин графа `V = ∞`. Відстань до `а = 0`. Жодна вершина графа ще не опрацьована.

![](https://upload.wikimedia.org/wikipedia/commons/4/48/Dijkstra_graph2.PNG)

Знаходимо таку вершину (із ще не оброблених), поточна найкоротша відстань до якої мінімальна. В нашому випадку це вершина __1__. Обходимо всіх її сусідів і, якщо шлях в сусідню вершину через __1__ менший за поточний мінімальний шлях в цю сусідню вершину, то запам'ятовуємо цей новий, коротший шлях як поточний найкоротший шлях до сусіда.

![](https://upload.wikimedia.org/wikipedia/commons/5/55/Dijkstra_graph3.PNG)

Перший по порядку сусід __1__-ї вершини — __2__-а вершина. Шлях до неї через __1__-у вершину дорівнює найкоротшій відстані до __1__-ї вершини + довжина дуги між __1__-ю та __2__-ю вершиною, тобто __0 + 7 = 7__. Це менше поточного найкоротшого шляху до __2__-ї вершини, тому найкоротший шлях до __2__-ї вершини дорівнює __7__.

![](https://upload.wikimedia.org/wikipedia/commons/c/c3/Dijkstra_graph4.PNG)
![](https://upload.wikimedia.org/wikipedia/commons/0/04/Dijkstra_graph5.PNG)

Аналогічну операцію проробляємо з двома іншими сусідами __1__-ї вершини — __3__-ю та __6__-ю.

![](https://upload.wikimedia.org/wikipedia/commons/b/b3/Dijkstra_graph6.PNG)

Всі сусіди вершини __1__ перевірені. Поточна мінімальна відстань до вершини __1__ вважається остаточною і обговоренню не підлягає _(те, що це дійсно так, вперше довів Дейкстра)_. Тому викреслимо її з графа, щоб відмітити цей факт.

![](https://upload.wikimedia.org/wikipedia/commons/f/f2/Dijkstra_graph7.PNG)

Практично відбувається повернення до кроку __2__. Знову знаходимо «найближчу» необроблену (невикреслену) вершину. Це вершина __2__ з поточною найкоротшою відстанню до неї = __7__. І знову намагаємося зменшити відстань до всіх сусідів __2__-ї вершини, намагаючись пройти в них через __2__-у. Сусідами __2__-ї вершини є __1__, __3__, __4__.

Перший (по порядку) сусід вершини __2__ — __1__-ша вершина. Але вона вже оброблена (або викреслена). Тому з __1__-ю вершиною нічого не робимо.

![](https://upload.wikimedia.org/wikipedia/commons/f/f4/Dijkstra_graph8.PNG)

Інший сусід вершини __2__ — вершина __4__. Якщо йти в неї через __2__-у, то шлях буде = найкоротша відстань до __2__-ї + відстань між __2__-ю і __4__-ю вершинами = __7 + 15 = 22__. Оскільки __22 < ∞__, встановлюємо відстань до вершини __4__ рівною __22__. 

![](https://upload.wikimedia.org/wikipedia/commons/f/fc/Dijkstra_graph9.PNG)

Ще один сусід вершини __2__ — вершина __3__. Якщо йти в неї через __2__-у, то шлях буде = __7 + 10 = 17__. Але __17__ більше за відстань, що вже запам'ятали раніше до вершини __3__ і дорівнює __9__, тому поточну відстань до __3__-ї вершини не міняємо.

![](https://upload.wikimedia.org/wikipedia/commons/4/4a/Dijkstra_graph10.PNG)

Всі сусіди вершини __2__ переглянуті, заморожуємо відстань до неї і викреслюємо її з графа. 

![](https://upload.wikimedia.org/wikipedia/commons/1/1d/Dijkstra_graph11.PNG)

По вже «відпрацьованій» схемі продовжуємо обробляти вершини. Тепер «найближчою» виявляється вершина  __3__. Проробляємо те саме з вершинами, що залишилися (__6__, __4__ і __5__).

![](https://upload.wikimedia.org/wikipedia/commons/a/a7/Dijkstra_graph14.PNG)

Алгоритм закінчує роботу, коли викреслені всі вершини. Результат його роботи видно на останньому малюнку: найкоротший шлях від __1__-ї вершини до __2__-ї становить __7__, до __3__-ї — __9__, до __4__-ї — __20__, до __5__-ї — __20__, до __6__-ї — __11__ умовних одиниць.
