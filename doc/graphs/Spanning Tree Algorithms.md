# Алгоритми побудови кістяка
## Алгоритм Крускала
### Загальна інформація
Візьмемо зважений зв'язний граф G=(V, E), де V — множина вершин, E — множина ребер, для кожного з яких задано вагу. Тоді ациклічна множина ребер, що поєднують усі вершини графа і чия загальна вага мінімальна, називається мінімальним кістяковим деревом.

Алгоритм Крускала починається з побудови виродженого лісу, що містить V дерев, кожне з яких складається з однієї вершини. Далі виконуються операції об'єднання двох дерев, для чого використовуються найкоротші можливі ребра, поки не утвориться єдине дерево. Це дерево і буде мінімальним кістяковим деревом.

Алгоритм Крускала (як і алгоритм Прима) є класичним алгоритмом розв'язання задачі пошуку мінімального кістякового дерева. У разі використання найшвидших реалізацій час його роботи становить `O(E\log E)`. Основна частина часу витрачається на сортування ребер за вагою.
### Алгоритм
На початку поточний безліч ребер встановлюється порожнім. Потім, поки це можливо, проводиться наступна операція: з усіх ребер, додавання яких до вже наявних не викличе появу циклу, вибирається ребро мінімальної ваги і додається до кістяка. Коли таких ребер більше немає, алгоритм завершений. 
### Приклад алгоритму
![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Prim_Algorithm_0.svg/300px-Prim_Algorithm_0.svg.png)

Початковий граф. Цифри над ребрами позначають їх вагу. Жодне з ребер не додане до кістякового дерева.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Kruskal_Algorithm_1.svg/300px-Kruskal_Algorithm_1.svg.png)

__AD__ і __CE__ мають найменшу вагу __5__, і __AD__ вибирається з них довільно та додається до кістякового дерева.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Kruskal_Algorithm_2.svg/300px-Kruskal_Algorithm_2.svg.png)

На цьому кроці __CE__ є найлегшим ребром з вагою __5__, тому воно також додається до дерева.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/Kruskal_Algorithm_3.svg/300px-Kruskal_Algorithm_3.svg.png)

Аналогічним чином обирається найлегше з недоданих ребер графа __DF__ з вагою __6__ і додається до кістякового дерева.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Kruskal_Algorithm_4.svg/300px-Kruskal_Algorithm_4.svg.png)

Наступними найлегшими ребрами є __AB__ і __BE__, обидва вагою __7__. __AB__ обирається довільно і додається до кістякового дерева. __BD__ фарбується у червоний колір, оскільки воно є частиною циклу __ABD__.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Kruskal_Algorithm_5.svg/300px-Kruskal_Algorithm_5.svg.png)

Наступним додається ребро __BE__ з вагою __7__. Червоним забарвлюємо ребра __BC__ (цикл __BCE__), __DE__ (цикл __DEBA__) і __FE__ (цикл __FEBAD__).

![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Kruskal_Algorithm_6.svg/300px-Kruskal_Algorithm_6.svg.png)

Додаємо ребро __EG__ вагою __9__ і отримуємо мінімальне кістякове дерево.

## Алгоритм Прима
### Загальна інформація
Алгоритм Прима — жадібний алгоритм побудови мінімального кістякового дерева зваженого зв'язного неорієнтованого графа.

Побудова починається з дерева, що включає в себе одну (довільну) вершину. Протягом роботи алгоритму дерево розростається, поки не охопить всі вершини вихідного графа. На кожному кроці алгоритму до поточного дереву приєднується найлегше з ребер, що з'єднують вершину з побудованого дерева і вершину, що не належить дереву.

Асимптотика алгоритму залежить від способу зберігання графа і способу зберігання вершин, що не входять в дерево. Якщо пріоритетна черга `Q` реалізована як звичайний масив `d`, то `Extract.Min(Q)` виконується за `O(n)`, а вартість операції `d [u] ← w(v, u)` становить `O(1)`. Якщо `Q` являє собою бінарну піраміду, то вартість `Extract.Min(Q)` знижується до `O(log n)`, а вартість `d [u] ← w(v, u)` зростає до `O(log n)`.
### Алгоритм
1. Спочатку ребра сортують за зростанням ваги.
2. Додають найменше ребро в дерево.
3. Зі списку ребер із найменшою вагою вибирають таке нове ребро, щоб одна з його вершин належала дереву, а інша — ні.
4. Це ребро додають у дерево і знову переходять до кроку 3.
5. Робота закінчується, коли всі вершини будуть у дереві.
### Приклад алгоритму
![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Prim_Algorithm_0.svg/300px-Prim_Algorithm_0.svg.png)

Вихідний зважений граф. Числа біля ребер показують їх ваги, які можна розглядати як відстані між вершинами.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Prim_Algorithm_1.svg/300px-Prim_Algorithm_1.svg.png)

Як початкова довільно вибирається вершина __D__. Кожна з вершин __A__, __B__, __E__ і __F__ з'єднана з __D__ єдиним ребром. Вершина __A__ — найближча до __D__, і вибирається як друга вершина разом з ребром __AD__.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Prim_Algorithm_2.svg/300px-Prim_Algorithm_2.svg.png)

Наступна вершина — найближча до будь-якої з обраних вершин __D__ або __A__. __B__ віддалена від __D__ на __9__ і від __A__ — на __7__. Відстань до __E__ дорівнює __15__, а до __F__ — __6__. __F__ є найближчою вершиною, тому вона включається в дерево __F__ разом з ребром __DF__.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Prim_Algorithm_4.svg/300px-Prim_Algorithm_4.svg.png)

Аналогічними кроками приходимо до такого дерева. У цьому випадку є можливість вибрати або __C__, або __E__, або __G__. __C__ віддалена від __B__ на __8__, __E__ віддалена від __B__ на __7__, а __G__ віддалена від __F__ на __11__. __E__ — найближча вершина, тому вибирається __E__ і ребро __BE__.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Prim_Algorithm_6.svg/300px-Prim_Algorithm_6.svg.png)

Єдина вершина, що залишилася — __G__. Відстань від __F__ до неї __11__, від __E__ — __9__. __E__ ближче, тому вибирається вершина __G__ і ребро __EG__.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/Prim_Algorithm_7.svg/300px-Prim_Algorithm_7.svg.png)

Вибрані всі вершини, мінімальне кістякове дерево побудовано.
